# Building a Tree in a ML Framework


### Concatenation of MSAs

Let's start by having a look at the AMAS help:

```
AMAS.py --help
usage: AMAS <command> [<args>]

The AMAS commands are:
  concat      Concatenate input alignments
  convert     Convert to other file format
  replicate   Create replicate data sets for phylogenetic jackknife
  split       Split alignment according to a partitions file
  summary     Write alignment summary
  remove      Remove taxa from alignment
  translate   Translate DNA alignment into protein alignment
  trim        Remove columns from alignment

Use AMAS <command> -h for help with arguments of the command of interest

positional arguments:
  command     Subcommand to run

optional arguments:
  -h, --help  show this help message and exit
```

and specifically, to the ```concat``` function:

```
AMAS.py concat --help
usage: AMAS.py [-h] [-p CONCAT_PART] [-t CONCAT_OUT] [-u {fasta,phylip,nexus,phylip-int,nexus-int}] [-y {nexus,raxml,unspecified}] [-e] [-c CORES] -i IN_FILES [IN_FILES ...] -f
               {fasta,phylip,nexus,phylip-int,nexus-int} -d {aa,dna}

Concatenate input alignments

optional arguments:
  -h, --help            show this help message and exit
  -p CONCAT_PART, --concat-part CONCAT_PART
                        File name for the concatenated alignment partitions. Default: 'partitions.txt'
  -t CONCAT_OUT, --concat-out CONCAT_OUT
                        File name for the concatenated alignment. Default: 'concatenated.out'
  -u {fasta,phylip,nexus,phylip-int,nexus-int}, --out-format {fasta,phylip,nexus,phylip-int,nexus-int}
                        File format for the output alignment. Default: fasta
  -y {nexus,raxml,unspecified}, --part-format {nexus,raxml,unspecified}
                        Format of the partitions file. Default: 'unspecified'
  -e, --check-align     Check if input sequences are aligned. Default: no check
  -c CORES, --cores CORES
                        Number of cores used. Default: 1

required arguments:
  -i IN_FILES [IN_FILES ...], --in-files IN_FILES [IN_FILES ...]
                        Alignment files to be taken as input. You can specify multiple files using wildcards (e.g. --in-files *fasta)
  -f {fasta,phylip,nexus,phylip-int,nexus-int}, --in-format {fasta,phylip,nexus,phylip-int,nexus-int}
                        The format of input alignment
  -d {aa,dna}, --data-type {aa,dna}
                        Type of data
```

Now we can concatenate our alignments:

```
AMAS.py concat -i Analyses/1-to-1_Alignments/gblock/*.fa -f fasta -d aa --part-format nexus
mv concatenated.out Analyses/IQ-TREE/My_Concat.fa
mv partitions.txt Analyses/IQ-TREE/
```

As a results you should have two files, a merged MSA and a partition file, where are stored the coordinate of the gene boundaries. Let's have a look at it:

```
head -n 20 partitions.txt 
#NEXUS

Begin sets;
	charset p1_OG0000030 = 1-197;
	charset p2_OG0000031 = 198-348;
	charset p3_OG0000032 = 349-1070;
	charset p4_OG0000033 = 1071-1512;
	charset p5_OG0000034 = 1513-1925;
	charset p6_OG0000035 = 1926-2300;
	charset p7_OG0000036 = 2301-2463;
	charset p8_OG0000037 = 2464-2867;
	charset p9_OG0000038 = 2868-3281;
	charset p10_OG0000039 = 3282-3703;
	charset p11_OG0000040 = 3704-4054;
	charset p12_OG0000041 = 4055-5124;
	charset p13_OG0000042 = 5125-5285;
	charset p14_OG0000043 = 5286-5482;
	charset p15_OG0000044 = 5483-6214;
	charset p16_OG0000045 = 6215-7227;
	charset p17_OG0000046 = 7228-7383;
```

>NOTE: We are working with proteins so our partitions file just store the starting and the ending position of each gene. However, if we were using nucleotide sequences of PCGs, we might also want the coordinates of all the first, second and third codon positions. Indeed, they evolve differently due to the gen code degeneracy and codon usage bias.

Now we are ready to carry out our model selection in a Maximum Likelihood framework...

### Model Selection


What we've seen until now is the process through which we select the "best" model of evolution for our sequence data, according to a metric of choice. However, when using concatenated alignments we don't want to loose *a priori* the information of the single genes boundaries. So let's use our partition file:

```
iqtree -s Analyses/IQ-TREE/My_Concat.fa -sp Analyses/IQ-TREE/partitions.txt -m TESTONLY
```

where the ```-sp``` option allows to take into consideration **[heterotachy](https://en.wikipedia.org/wiki/Heterotachy)** ( allowing each partitions to have its own set of branch lengths. **NB** very parameter rich, take a look at [this](https://academic.oup.com/mbe/article/37/4/1202/5673393?login=true) pubblication). Other options are:

* ```-q```:   all partitions share the same set of branch lengths (unrealistic).
* ```-spp```: allows each partition to have its own evolution rate but in a proportioal way (recommended for typical analysis).

The resulting file should look something like this:

```
cat Analyses/IQ-TREE/partitions.txt.best_scheme.nex
#nexus
begin sets;
  charset p1_OG0000030 = 1-197;
  charset p2_OG0000031 = 198-348;
  charset p3_OG0000032 = 349-1070;
  charset p4_OG0000033 = 1071-1512;
  charset p5_OG0000034 = 1513-1925;
  charset p6_OG0000035 = 1926-2300;
  charset p7_OG0000036 = 2301-2463;
  charset p8_OG0000037 = 2464-2867;
  charset p9_OG0000038 = 2868-3281;
  charset p10_OG0000039 = 3282-3703;
  charset p11_OG0000040 = 3704-4054;
  ...
  charpartition mymodels =
    LG+G4: p8_OG0000037,
    LG+G4: p9_OG0000038,
    LG+G4: p10_OG0000039,
    LG+G4: p11_OG0000040,
    JTT+F+G4: p12_OG0000041,
    LG+G4: p13_OG0000042,
    JTT+I: p14_OG0000043,
    LG+F+G4: p15_OG0000044,
    LG+F+G4: p16_OG0000045,
    LG+G4: p17_OG0000046,
    LG+G4: p18_OG0000047,
    ...
end; 
```

Here we can see the best-fit model for each partition, but take a look at the iqtree file for detailed informations.


Now, we can rerun the analyses using the ```-spp``` option:

```
iqtree -s Analyses/IQ-TREE/My_Concat.fa -spp Analyses/IQ-TREE/partitions.txt -m TESTONLY --prefix spp
```
The choice between -spp and -sp model can be made by looking at the **BIC scores** of the resulting models

```
varSP=$( grep "Bayesian information criterion (BIC) score:"  Analyses/IQ-TREE/partitions.txt.iqtree | cut -d" " -f6)
varSPP=$( grep "Bayesian information criterion (BIC) score:" spp.iqtree | cut -d" " -f6)
echo -e "$varSP\n$varSPP"
481216.3913
478647.5903
```
As we can see in this case the best-fit partitioning scheme was found with the ```-spp option``` (the **lower** the BIC score, the **higher** the fitness of the model).

---



## unpartitioned analyses:


During last lesson we found the best-fit model of evolution without doing tree reconstruction, but we can perform both the search for the best-fit model and the phylogenetic inference by just using the ```-m MFP``` flag. After ModelFinder, IQ-TREE will immediately start the tree reconstruction under the best-fit partition model. 

A good practice in phylogenetic inference is to build up single gene trees, in this way you can get usefull informations about your markers (are all gene trees telling you the same story? Which are the more informative markers? Are present markers with a different evolutionary history compared to others? Which markers shows more concordance with bibliography knowledge?). If we have a lot of markers, as in our case, we can quickly build up gene trees in two different ways:

 * **1:** Cycle a model selection followed by tree reconstruction inside our alignment folder.
 * **2:** Using ```-S``` flag followed by the name of the directory were are stored the alignments.

Let's use the latest one:

```
mkdir Analyses/IQ-TREE/Gene_Trees
iqtree -S Analyses/1-to-1_Alignments/gblock/ --prefix Analyses/IQ-TREE/Gene_Trees/loci
```
IQ-TREE automatically detects that ```gblock``` is a directory and will load all alignments within the directory.

Here are the outputs:

* ```.best_scheme.nex``` best fit partitioning scheme (in our case is just one partition for gene).
* ```.best_model.nex``` best-fit evolutionary model for each partition. 
* ```.iqtree``` is the analysis report.
* ```.model.gz``` is the complete evolutionary model.
* ```.treefile``` is the set Maximum Likelihood gene trees.
* ```.log``` is the screen log.
* ```.ckp.gz``` is just a checkpoint file. 

If we followed the for loop way, we will have one of this output files for each gene tree, thus filling our working directory with tones of files.

Let's take a deeper look at the log file, the IQ-TREE report, and the .treefile file:

```
less -S Analyses/IQ-TREE/Gene_Trees/loci.log
less -S Analyses/IQ-TREE/Gene_Trees/loci.iqtree
cat Analyses/IQ-TREE/Gene_Trees/loci.treefile
```

>Remember that most phylogenetic programs produce unrooted trees, as they are not aware about any biological background. We can root them using our *a priori* biological knowledge or use approches as the mid point rooting.

From the ```.treefile``` we can easly extract single gene trees if we want to manually look at them (**NB:** trees are in the same order as input data, unfortunately they are not annotated). However, if we have a lot of loci, is better to first find an automatic way able to easly highlights and summarize differences between a set of trees. For this purpose, IQ-TREE implements the Robinson-Foulds distances calculation, a metric able to compare topologies between **binary** but **unrooted** trees (see [here](https://www.cs.hmc.edu/~hadas/mitcompbio/treedistance.html) for an in-depth explanation on computational methods). In brief it measures the symmetric difference between two trees by adding the number of splits (*i.e* edges) that are present in tree A (but not tree B) to the number of splits present in tree B (but not tree A).
